class Solution {
  // 1. each restriction can affect some nodes, to left and to right.
  // 2. Overlapped effect can be combined.

  // from 1, we know that we can use a bfs, from a heap.
  // some kind of like Dijkstra.

  // But a better way is using two pass. scan from left, then scan from right
  // Why this could work?
  // A node can only be affected by two combined effect, one from left, one from right.
  // Effect from left can only generated by nodes at its left. Same for effect from right.

  // So, after compute combined effect, we get a real restrction for nodes
  // And as long as height is in the real restrction, it fits global restrction.

  public int maxBuilding(int n, int[][] rtcs) {
    if(rtcs.length == 0) return n - 1; // no resctriction -> increase all the way down
    Arrays.sort(rtcs, (a, b) -> a[0] - b[0]); // sort by id

    // from left. handle rtcs[0] seperatly
    // limit of increase is handled by step length.
    rtcs[0][1] = Math.min(rtcs[0][1], rtcs[0][0] - 1);
    for (int i = 1; i < rtcs.length; i++) {
      rtcs[i][1] = Math.min(rtcs[i][1], rtcs[i-1][1] + rtcs[i][0] - rtcs[i-1][0]);
    }

    // from right
    for (int i = rtcs.length - 2; i >= 0; i--) {
      rtcs[i][1] = Math.min(rtcs[i][1], rtcs[i+1][1] + rtcs[i+1][0] - rtcs[i][0]);
    }
    // for (int[] row : rtcs) System.out.println(Arrays.toString(row));

    // start compute. All resctrictions are real resctrictions now.
    // max - pH + max - h == steps
    // max = (pH + h + steps) / 2
    int res = 0, preId = 1, preH = 0;
    for (int i = 0; i < rtcs.length; i++) {
      int max = (preH + rtcs[i][1] + rtcs[i][0] - preId) / 2;
      // System.out.println(i + " " + rtcs[i][0] + " " + max);
      res = Math.max(res, max);
      preId = rtcs[i][0];
      preH = rtcs[i][1];
    }

    // remember to handle tail.
    res = Math.max(res, (n - preId) + preH);
    return res;
  }
}
